<html>
<head>
<title>1999年第五届提高组试题解析</title>
<link rel="stylesheet" href="style.css"></head>
<body>
<center>

<h1>NOI分区联赛 - 1999年第五届提高组试题解析</h1>
</center>
<pre>
注意：解析和源程序均为OIBH站长刘汝佳所写，疏漏在所难免，但至少程序均通过了比赛时使用的测试数据，
所以还是可以一看。

第一题  拦截导弹（28分）
　　某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统
有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高
于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以
只有一套系统，因此有可能不能拦截所有的导弹。
　　输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000 的正整数），计算
这套系统最多能拦截多少导弹，和如果要拦截所有导弹最少要配备多少套这种导弹拦截
系统。
样例：
INPUT 
389 207 155 300 299 170 158 65  
OUTPUT
  6（最多能拦截的导弹数）                   
  2（要拦截所有导弹最少要配备的系统数）
                                                                                                                                        

[分析]
有经验的选手一看第一个问就知道是经典的动态规划 - 最长不升子序列。
令d[k]为打中第k枚导弹以后，含第k枚导弹在内一共最多可以打k枚,则有状态转移方程：
d[k]=           MAX       {d[i]+1,1}
     (i>k)and(d[i]<=d[k])
显然有d[n]=1，故从n逆推至d[1]即可,则 MAX{d[k]}为所求。
                                   1<=k<=n

第二问显然要难一点，最直观的算法是贪心，但是反例也容易找到，如：
6 5 1 7 3 2
如果第一次打6 5 3 2,显然还要打两次，而最好的方案是6 5 1/7 3 2。
显然失败之处在于第一种方案为了多打3和2，把1和7隔断了，
但事实上把3和2留给第二套打
还不是一样！因为每个导弹都要打到，故我们应该把注意力放在“打到每一枚导弹”。
在上一个例子中，7是必须打到的，

  因为它是最高的，所以必有一次拦截是以7开头的！！！

既然是必须，那么打7的同时顺便打一打其他的绝对不比不打差！那么打哪些呢？
下面说明：应该打后面导弹中最高的一个K。
先定义一个概念：把当前能打的最大高度叫做“能力”
理由如下：
对于K以后的导弹，绝对该打K，因为对于K以后的导弹，不打K时能打到的，打了K也能打到（K是最高的嘛！）,
K等于是“白打”，而对于7和K之间的导弹，打了任何一个就一定不能再打K了（K最高嘛！）反正中间的和
K不能一次打，先打不会比后打差！
类似的，下一个目标是K后面的最高的。
可以证明，该算法是正确的（从略），基础较好的同学也可以通过建立有向无环图来理解和证明这一算法。

程序见附件。

第二题 同普及组第二题，参见普及组试题解析

第三题 同普及组第三题，参见普及组试题解析

第四题 邮票面值设计（40分）
      给定一个信封，最多只允许粘贴N张邮票，计算在给定K（N+k&lt;=40) 种邮票的情况
下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大max ，使得1－
max之间的每一个邮资值都能得到。
      例如，N=3，K＝2，如果面值分别为1分、4分，则在l分-6分之间的每一个邮资值
都能得到（当然还有8分、9分和12分）：如果面值分别为1分、3分，则在1分-7分之间的
每一个邮资值都能得到。可以验证当N=3，K＝2时，7分就是可以得到连续的邮资最大值
，所以MAX=7，面值分别为l分、3分。
  样例：
  INPUT 
  N=3 k=2
  OUTPUT
  1  3
  MAX=7

[分析]
不知同学们第一个感觉是不是递推？反正我当时是。我想了一会儿，发现递推是行不通的，
然后一个很自然的思路就是搜索。当时我很不想用搜索，因为上限是K=40,N=40,但后来才知道
这是出题者的一个疏忽，根本不可能在时限内到40的。从下面的测试数据中也可以看出来。
解状态是一个K元组(v1,v2,v3..vk),不妨设：v1<v2<v3..<vk，那么我们从v2开始搜索（v1=1,这是显然的）。
搜索方法如下：
设前p个面值可以连续得到1~R,则第P+1个面值可能是v[p]+1到R+1,因为v[p+1]>v[p],而若v[p]>=R+2,
则R+1根本不可能取到。
递归搜索就可以了。

本题的难点是如何计算最大连续值（以下成为Q值）。
一个容易想到的方法是枚举所有的取法，求出可以取到的最大值，再求Q值，简单，但是效率不高。
以下是供参考的递推方法：
递推求Q值，保存前P个面值用1,2,3..K张可以取得的值，再加上第P+1张取与不取的情况可以得到前P+1个面值
用1,2,3..K张可以取得的值。即，用T张前P个面值能得到S,用T+1张前P+1个面值可以得到S+V[P+1],用T张前
P+1个面值也能得到S.
为了使程序易懂，我采用的是简单的方法，效率低一些，但是好懂一些。以下我竞赛时写的程序，后来加了
很多注释，将就看一下吧！
我先把可能不好懂的地方说一下：
1.Cont(x)就是前x个元素的Q值
2.Find(Findstart,Contstart,x); x:当前搜索的邮票序号，findstart:第x张邮票的最小可能值（搜索起点），
  Contstart:需要从Contstart开始连续取值（也就是：前x-1张可以从1取到Contstart-1）
程序见附件。

测试数据见附件。

Copyright OIBH http://oibh.yeah.net
</pre>

</html>
